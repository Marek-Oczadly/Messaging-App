// Author : Marek Oczadly
// License : MIT
// UnitTests.cpp

#include <iomanip>
#include <cstdint>
#include "pch.h"
#include "CppUnitTest.h"

#if defined(_DEBUG)
#include "largeInt.hpp"
#include "utils.hpp"
#include "bitwise-functions.hpp"

#else
/*
For some reason the linker fails to find these definitions in release mode as the compile command is run in Messaging-App\Test\UnitTests\.
but the files are located in Messaging-App\ so the relative path needs to go up two directories. I cannot be bothered to fix this properly
in the project settings right now so this is a quick fix.
*/
#include "../../largeInt.hpp"
#include "../../utils.hpp"
#include "../../bitwise-functions.hpp"

#endif

using namespace Microsoft::VisualStudio::CppUnitTestFramework;


#define DEFINE_UINT_ARRAY_TOSTRING(N)											\
namespace Microsoft {															\
	namespace VisualStudio {													\
		namespace CppUnitTestFramework {										\
			template <>															\
			std::wstring ToString<uint_array<N>>(const uint_array<N>& q) {		\
				return q.toWString();											\
			}																	\
		}																		\
	}																			\
}

#define DEFINE_ARR_TO_STRING(N)													\
namespace Microsoft {															\
	namespace VisualStudio {													\
		namespace CppUnitTestFramework {										\
			template <>															\
			std::wstring ToString<Arr64<N>>(const Arr64<N>& q) {				\
				return byteArrayToBinaryString<N>(q);							\
			}																	\
		}																		\
	}																			\
}


#ifdef DEFINE_UINT_ARRAY_TOSTRING
DEFINE_UINT_ARRAY_TOSTRING(4);
DEFINE_UINT_ARRAY_TOSTRING(8);
DEFINE_UINT_ARRAY_TOSTRING(16);
#endif

#ifdef DEFINE_ARR_TO_STRING
DEFINE_ARR_TO_STRING(1);
DEFINE_ARR_TO_STRING(2);
DEFINE_ARR_TO_STRING(4);
#endif


namespace LARGE_INT {
	TEST_CLASS(BASIC_ARITMETIC) {
	
	public:

		TEST_METHOD(EXPECTED_BITFLIP) {
			int64_t temp = INT64_MIN;
			uint64_t a = *reinterpret_cast<uint64_t*>(&temp);
			uint64_t expected = ~a + 1;
			uint64_t test = -(*reinterpret_cast<int64_t*>(&a));
			Assert::AreEqual(test, expected);
		}

		TEST_METHOD(BASIC_256_ADDITION) {
			uint256_t a = { 1, 1, 1, 1 };
			uint256_t b = { 2, 2, 2, 2 };

			Assert::AreEqual(a + b, uint256_t{ 3, 3, 3, 3 });
		}

		TEST_METHOD(BASIC_256_SUBTRACTION) {
			uint256_t a = { 5, 5, 5, 5 };
			uint256_t b = { 2, 2, 2, 2 };

			Assert::AreEqual(a - b, uint256_t{ 3, 3, 3, 3 });
		}

		TEST_METHOD(ADDITION_256_OVERFLOW) {
			uint256_t a = { 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF };
			uint256_t b = { 0, 0, 0, 1 };
			// This should overflow and wrap around
			// Keep getting {0, FF..., FF..., FF... } 
			Assert::AreEqual(uint256_t{ 0, 0, 0, 0 }, a + b);
		}

		TEST_METHOD(SUBTRACTION_256_UNDERFLOW) {
			uint256_t a = { 0, 0, 0, 0 };
			uint256_t b = { 0, 0, 0, 1 };
			// This should underflow and wrap around
			Assert::AreEqual(uint256_t{ 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF }, a - b);
		}

		TEST_METHOD(ADDITION_512_256) {
			uint512_t a = { 1, 1, 1, 1, 1, 1, 1, 1 };
			uint256_t b = { 2, 2, 2, 2 };

			Assert::AreEqual(uint512_t{ 1, 1, 1, 1, 3, 3, 3, 3 }, a + b);
		}
		TEST_METHOD(ADDITION_512_256_OVERFLOW) {
			uint512_t a = { 0, 0, 0, 0, 0, 0, 0, 1 };
			uint256_t b = { 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF };
			uint512_t expected = { 0, 0, 0, 1, 0, 0, 0, 0 };

			Assert::AreEqual(expected, a + b);
		}

		TEST_METHOD(ADDITION_256_512_OVERFLOW) {
			uint512_t a = { 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF };
			uint256_t b = { 0x0, 0x0, 0x0, 0x1 };
			uint512_t expected = { 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0 };

			Assert::AreEqual(expected, a + b);
		}

		TEST_METHOD(SUBTRACTION_512_256) {
			uint512_t a = { 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0 };
			uint256_t b = { 0x0, 0x0, 0x0, 0x1 };
			uint512_t expected = { 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF };

			Assert::AreEqual(expected, a - b);
		}

		TEST_METHOD(SUBTRACTION_256_512) {
			uint256_t a = { 0x0, 0x0, 0x35, 0x0 };
			uint512_t b = { 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0 };

			uint512_t expected = 
				{ 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0x0, 0x0, 0x35, 0x0 };
			Assert::AreEqual(expected, a - b);
		}

		TEST_METHOD(EQUAL_SIZE) {
			Assert::AreEqual(sizeof(uint256_t), sizeof(uint64_t) * 4);
		}
	};
}

// DO NOT CHANGE
namespace BITWISE_FUNCTIONS {
	TEST_CLASS(LEFT_SHIFT_INPLACE_RUNTIME) {

		TEST_METHOD(LEFT_SHIFT_NO_BYTES) {
			Arr64<1> test = { { 0b0101011011001010110101111101001011000100001011011110110100101101ULL} };
			const uint8_t places = 13U;

			Arr64<1> expected = { 0b0101011011001010110101111101001011000100001011011110110100101101ULL << places };
			leftShiftInPlace(test, places);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_NO_PLACES) {
			Arr64<2> test = { 0x1234567890ABCDEF, 0x0FEDCBA098765432 };

			const uint8_t places = 0u;
			Arr64<2> expected = test;
			leftShiftInPlace(test, places);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_SIMPLE) {
			Arr64<2> test = { 0x0000000000000001, 0x0000000000000000 };
			const uint8_t places = 4;

			Arr64<2> expected = { 0x0000000000000010, 0x0000000000000000 };
			leftShiftInPlace(test, places);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_ACROSS_BOUNDARY) {
			Arr64<2> test = { 0x0000000000000001, 0x0000000000000002 };
			const uint8_t places = 68;
			Arr64<2> expected = { 0x0000000000000020, 0x0000000000000000 };

			leftShiftInPlace(test, places);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_FULL_WORD) {
			Arr64<2> test = { 0xAAAAAAAAAAAAAAAA, 0x5555555555555555 };
			const uint8_t places = 64;
			Arr64<2> expected = { 0x5555555555555555, 0x0000000000000000 };

			leftShiftInPlace(test, places);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_BEYOND_WIDTH) {
			Arr64<4> test = { 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF };
			const uint16_t places = 267;	// 4*64=256 < 260 < 5*64=320
			Arr64<4> expected = { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 };

			leftShiftInPlace(test, places);
			Assert::AreEqual(expected, test);

		}

		TEST_METHOD(LEFT_SHIFT_AUTO_1) {	// Values generated randomly from python script
			Arr64<4> test = { 0b0010010010011111111011000001011011000101100101010010000100001010, 0b0001001111000111111110101010100000110100001011100011001011101111, 0b1111010100100101111000101101110100101010110011001111110010001110, 0b0001010101111001101110001100011010101010111001011101010100001001 };
			const uint16_t places = 169;
			Arr64<4> expected = { 0b1001100111111001000111000010101011110011011100011000110101010101, 0b1100101110101010000100100000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			leftShiftInPlace(test, places);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_AUTO_2) {
			Arr64<4> test = { 0b0000000111001111101011000001111010100010001011101001100011100101, 0b0011110110101111000000011001001010101100011110110101100000110011, 0b0011011011011110100010001010110000001100000100000000011100000010, 0b1000111110100101100010111111001010010110101101110101111100110010 };
			const uint16_t places = 131;
			Arr64<4> expected = { 0b1011011011110100010001010110000001100000100000000011100000010100, 0b0111110100101100010111111001010010110101101110101111100110010000, 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			leftShiftInPlace(test, places);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_AUTO_3) {
			Arr64<4> test = { 0b1111000001000111001111100000010000100111011101100011101010001000, 0b0111100101111000010111011011010101011001001010110010000000111111, 0b0111000101111011110101011111110101011010110110100010001100101101, 0b0100111100101110110001000111100100010111001100001100101101101000 };
			const uint16_t places = 68;
			Arr64<4> expected = { 0b1001011110000101110110110101010110010010101100100000001111110111, 0b0001011110111101010111111101010110101101101000100011001011010100, 0b1111001011101100010001111001000101110011000011001011011010000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			leftShiftInPlace(test, places);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_AUTO_4) {
			Arr64<4> test = { 0b0110101101010001000100001101011001100010010010011111001111100110, 0b1111110000100110000000011111011010111011110110001010001011101100, 0b0010111111001010111001111010011001101100111100010101101011101001, 0b0000101110000111001000010000001001010000101001000000000011111010 };
			const uint16_t places = 124;
			Arr64<4> expected = { 0b1100001011111100101011100111101001100110110011110001010110101110, 0b1001000010111000011100100001000000100101000010100100000000001111, 0b1010000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			leftShiftInPlace(test, places);
			Assert::AreEqual(expected, test);
		}
	};


	TEST_CLASS(LEFT_SHIFT_RUNTIME) {

	public:
		TEST_METHOD(LEFT_SHIFT_NO_BYTES) {
			Arr64<1> test = { { 0b0101011011001010110101111101001011000100001011011110110100101101ULL} };
			const uint8_t places = 13U;

			Arr64<1> expected = { 0b0101011011001010110101111101001011000100001011011110110100101101ULL << places };
			Assert::AreEqual(expected, leftShift(test, places));
		}

		TEST_METHOD(LEFT_SHIFT_NO_PLACES) {
			Arr64<2> test = { 0x1234567890ABCDEF, 0x0FEDCBA098765432 };

			const uint8_t places = 0u;
			Arr64<2> expected = test;
			Assert::AreEqual(expected, leftShift(test, places));
		}

		TEST_METHOD(LEFT_SHIFT_SIMPLE) {
			Arr64<2> test = {0x0000000000000001, 0x0000000000000000};
			const uint8_t places = 4;

			Arr64<2> expected = { 0x0000000000000010, 0x0000000000000000 };
			Assert::AreEqual(expected, leftShift(test, places));
		}

		TEST_METHOD(LEFT_SHIFT_ACROSS_BOUNDARY) {
			Arr64<2> test = { 0x0000000000000001, 0x0000000000000002 };
			const uint8_t places = 68;
			Arr64<2> expected = { 0x0000000000000020, 0x0000000000000000 };
			Assert::AreEqual(expected, leftShift(test, places));
		}

		TEST_METHOD(LEFT_SHIFT_FULL_WORD) {
			Arr64<2> test = { 0xAAAAAAAAAAAAAAAA, 0x5555555555555555 };
			const uint8_t places = 64;
			Arr64<2> expected = { 0x5555555555555555, 0x0000000000000000 };
			Assert::AreEqual(expected, leftShift(test, places));
		}

		TEST_METHOD(LEFT_SHIFT_BEYOND_WIDTH) {
			Arr64<4> test = { 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF };
			const uint16_t places = 267;	// 4*64=256 < 260 < 5*64=320
			Arr64<4> expected = { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 };
			Assert::AreEqual(expected, leftShift(test, places));
		}
		TEST_METHOD(LEFT_SHIFT_AUTO_1) {	// Values generated randomly from python script
			Arr64<4> test = { 0b0010010010011111111011000001011011000101100101010010000100001010, 0b0001001111000111111110101010100000110100001011100011001011101111, 0b1111010100100101111000101101110100101010110011001111110010001110, 0b0001010101111001101110001100011010101010111001011101010100001001 };
			const uint16_t places = 169;
			Arr64<4> expected = { 0b1001100111111001000111000010101011110011011100011000110101010101, 0b1100101110101010000100100000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			Assert::AreEqual(expected, leftShift(test, places));
		}

		TEST_METHOD(LEFT_SHIFT_AUTO_2) {
			Arr64<4> test = { 0b0000000111001111101011000001111010100010001011101001100011100101, 0b0011110110101111000000011001001010101100011110110101100000110011, 0b0011011011011110100010001010110000001100000100000000011100000010, 0b1000111110100101100010111111001010010110101101110101111100110010 };
			const uint16_t places = 131;
			Arr64<4> expected = { 0b1011011011110100010001010110000001100000100000000011100000010100, 0b0111110100101100010111111001010010110101101110101111100110010000, 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			Assert::AreEqual(expected, leftShift(test, places));
		}

		TEST_METHOD(LEFT_SHIFT_AUTO_3) {
			Arr64<4> test = { 0b1111000001000111001111100000010000100111011101100011101010001000, 0b0111100101111000010111011011010101011001001010110010000000111111, 0b0111000101111011110101011111110101011010110110100010001100101101, 0b0100111100101110110001000111100100010111001100001100101101101000 };
			const uint16_t places = 68;
			Arr64<4> expected = { 0b1001011110000101110110110101010110010010101100100000001111110111, 0b0001011110111101010111111101010110101101101000100011001011010100, 0b1111001011101100010001111001000101110011000011001011011010000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			Assert::AreEqual(expected, leftShift(test, places));
		}

		TEST_METHOD(LEFT_SHIFT_AUTO_4) {
			Arr64<4> test = { 0b0110101101010001000100001101011001100010010010011111001111100110, 0b1111110000100110000000011111011010111011110110001010001011101100, 0b0010111111001010111001111010011001101100111100010101101011101001, 0b0000101110000111001000010000001001010000101001000000000011111010 };
			const uint16_t places = 124;
			Arr64<4> expected = { 0b1100001011111100101011100111101001100110110011110001010110101110, 0b1001000010111000011100100001000000100101000010100100000000001111, 0b1010000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			Assert::AreEqual(expected, leftShift(test, places));
		}
	};

	TEST_CLASS(LEFT_SHIFT_INPLACE_COMPILETIME) {

		TEST_METHOD(LEFT_SHIFT_1_ELEM) {
			Arr64<1> test = { { 0b0101011011001010110101111101001011000100001011011110110100101101ULL} };
			constexpr uint8_t places = 13U;

			Arr64<1> expected = { 0b0101011011001010110101111101001011000100001011011110110100101101ULL << places };
			leftShiftInPlace<1, places>(test);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_NO_PLACES) {
			Arr64<2> test = { 0x1234567890ABCDEF, 0x0FEDCBA098765432 };
			constexpr uint8_t places = 0u;
			Arr64<2> expected = test;
			leftShiftInPlace<2, places>(test);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_SIMPLE) {
			Arr64<2> test = { 0x0000000000000001, 0x0000000000000000 };
			constexpr uint8_t places = 4;
			Arr64<2> expected = { 0x0000000000000010, 0x0000000000000000 };
			leftShiftInPlace<2, places>(test);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_ACROSS_BOUNDARY) {
			Arr64<2> test = { 0x0000000000000001, 0x0000000000000002 };
			constexpr uint8_t places = 68;
			Arr64<2> expected = { 0x0000000000000020, 0x0000000000000000 };
			leftShiftInPlace<2, places>(test);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_FULL_WORD) {
			Arr64<2> test = { 0xAAAAAAAAAAAAAAAA, 0x5555555555555555 };
			constexpr uint8_t places = 64;
			Arr64<2> expected = { 0x5555555555555555, 0x0000000000000000 };
			leftShiftInPlace<2, places>(test);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_BEYOND_WIDTH) {
			Arr64<4> test = { 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF };
			constexpr uint16_t places = 267;	// 4*64=256 < 260 < 5*64=320
			Arr64<4> expected = { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 };
			leftShiftInPlace<4, places>(test);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_AUTO_1) {	// Values generated randomly from python script
			Arr64<4> test = { 0b0010010010011111111011000001011011000101100101010010000100001010, 0b0001001111000111111110101010100000110100001011100011001011101111, 0b1111010100100101111000101101110100101010110011001111110010001110, 0b0001010101111001101110001100011010101010111001011101010100001001 };
			constexpr uint16_t places = 169;
			Arr64<4> expected = { 0b1001100111111001000111000010101011110011011100011000110101010101, 0b1100101110101010000100100000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			leftShiftInPlace<4, places>(test);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_AUTO_2) {
			Arr64<4> test = { 0b0000000111001111101011000001111010100010001011101001100011100101, 0b0011110110101111000000011001001010101100011110110101100000110011, 0b0011011011011110100010001010110000001100000100000000011100000010, 0b1000111110100101100010111111001010010110101101110101111100110010 };
			constexpr uint16_t places = 131;
			Arr64<4> expected = { 0b1011011011110100010001010110000001100000100000000011100000010100, 0b0111110100101100010111111001010010110101101110101111100110010000, 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			leftShiftInPlace<4, places>(test);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_AUTO_3) {
			Arr64<4> test = { 0b1111000001000111001111100000010000100111011101100011101010001000, 0b0111100101111000010111011011010101011001001010110010000000111111, 0b0111000101111011110101011111110101011010110110100010001100101101, 0b0100111100101110110001000111100100010111001100001100101101101000 };
			constexpr uint16_t places = 68;
			Arr64<4> expected = { 0b1001011110000101110110110101010110010010101100100000001111110111, 0b0001011110111101010111111101010110101101101000100011001011010100, 0b1111001011101100010001111001000101110011000011001011011010000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			leftShiftInPlace<4, places>(test);
			Assert::AreEqual(expected, test);
		}

		TEST_METHOD(LEFT_SHIFT_AUTO_4) {
			Arr64<4> test = { 0b0110101101010001000100001101011001100010010010011111001111100110, 0b1111110000100110000000011111011010111011110110001010001011101100, 0b0010111111001010111001111010011001101100111100010101101011101001, 0b0000101110000111001000010000001001010000101001000000000011111010 };
			constexpr uint16_t places = 124;
			Arr64<4> expected = { 0b1100001011111100101011100111101001100110110011110001010110101110, 0b1001000010111000011100100001000000100101000010100100000000001111, 0b1010000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			leftShiftInPlace<4, places>(test);
			Assert::AreEqual(expected, test);
		}
	};

	TEST_CLASS(LEFT_SHIFT_COMPILETIME) {

	public:
		TEST_METHOD(LEFT_SHIFT_1_ELEM) {
			Arr64<1> test = { { 0b0101011011001010110101111101001011000100001011011110110100101101ULL} };
			constexpr uint8_t places = 13U;

			Arr64<1> expected = { 0b0101011011001010110101111101001011000100001011011110110100101101ULL << places };
			Assert::AreEqual(expected, leftShift<1, places>(test));
		}

		TEST_METHOD(LEFT_SHIFT_NO_PLACES) {
			Arr64<2> test = { 0x1234567890ABCDEF, 0x0FEDCBA098765432 };

			constexpr uint8_t places = 0u;

			Arr64<2> expected = test;
			Assert::AreEqual(expected, leftShift<2, places>(test));
		}

		
		TEST_METHOD(LEFT_SHIFT_SIMPLE) {
			Arr64<2> test = { 0x0000000000000001, 0x0000000000000000 };
			constexpr uint8_t places = 4;

			Arr64<2> expected = { 0x0000000000000010, 0x0000000000000000 };

			Assert::AreEqual(expected, leftShift<2, places>(test));
		}
		
		TEST_METHOD(LEFT_SHIFT_ACROSS_BOUNDARY) {
			Arr64<2> test = { 0x0000000000000001, 0x0000000000000002 };
			constexpr uint8_t places = 68;
			Arr64<2> expected = { 0x0000000000000020, 0x0000000000000000 };
			Assert::AreEqual(expected, leftShift<2, places>(test));
		}

		TEST_METHOD(LEFT_SHIFT_FULL_WORD) {
			Arr64<2> test = { 0xAAAAAAAAAAAAAAAA, 0x5555555555555555 };
			constexpr uint8_t places = 64;
			Arr64<2> expected = { 0x5555555555555555, 0x0000000000000000 };
			Assert::AreEqual(expected, leftShift<2, places>(test));
		}

		TEST_METHOD(LEFT_SHIFT_BEYOND_WIDTH) {
			Arr64<4> test = { 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF };
			constexpr uint16_t places = 267;	// 4*64=256 < 260 < 5*64=320
			Arr64<4> expected = { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 };
			Assert::AreEqual(expected, leftShift<4, places>(test));
		}

		TEST_METHOD(LEFT_SHIFT_AUTO_1) {	// Values generated randomly from python script
			Arr64<4> test = { 0b0010010010011111111011000001011011000101100101010010000100001010, 0b0001001111000111111110101010100000110100001011100011001011101111, 0b1111010100100101111000101101110100101010110011001111110010001110, 0b0001010101111001101110001100011010101010111001011101010100001001 };
			constexpr uint16_t places = 169;
			Arr64<4> expected = { 0b1001100111111001000111000010101011110011011100011000110101010101, 0b1100101110101010000100100000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			Assert::AreEqual(expected, leftShift<4, places>(test));
		}

		TEST_METHOD(LEFT_SHIFT_AUTO_2) {
			Arr64<4> test = { 0b0000000111001111101011000001111010100010001011101001100011100101, 0b0011110110101111000000011001001010101100011110110101100000110011, 0b0011011011011110100010001010110000001100000100000000011100000010, 0b1000111110100101100010111111001010010110101101110101111100110010 };
			constexpr uint16_t places = 131;
			Arr64<4> expected = { 0b1011011011110100010001010110000001100000100000000011100000010100, 0b0111110100101100010111111001010010110101101110101111100110010000, 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			Assert::AreEqual(expected, leftShift<4, places>(test));
		}

		TEST_METHOD(LEFT_SHIFT_AUTO_3) {
			Arr64<4> test = { 0b1111000001000111001111100000010000100111011101100011101010001000, 0b0111100101111000010111011011010101011001001010110010000000111111, 0b0111000101111011110101011111110101011010110110100010001100101101, 0b0100111100101110110001000111100100010111001100001100101101101000 };
			constexpr uint16_t places = 68;
			Arr64<4> expected = { 0b1001011110000101110110110101010110010010101100100000001111110111, 0b0001011110111101010111111101010110101101101000100011001011010100, 0b1111001011101100010001111001000101110011000011001011011010000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			Assert::AreEqual(expected, leftShift<4, places>(test));
		}

		TEST_METHOD(LEFT_SHIFT_AUTO_4) {
			Arr64<4> test = { 0b0110101101010001000100001101011001100010010010011111001111100110, 0b1111110000100110000000011111011010111011110110001010001011101100, 0b0010111111001010111001111010011001101100111100010101101011101001, 0b0000101110000111001000010000001001010000101001000000000011111010 };
			constexpr uint16_t places = 124;
			Arr64<4> expected = { 0b1100001011111100101011100111101001100110110011110001010110101110, 0b1001000010111000011100100001000000100101000010100100000000001111, 0b1010000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };

			Assert::AreEqual(expected, leftShift<4, places>(test));
		}
	};

	TEST_CLASS(RIGHT_SHIFT_INPLACE_COMPILETIME) {
	public:
		
		TEST_METHOD(RIGHT_SHIFT_NO_PLACES) {
			Arr64<4> test = { 0b0010010010010101011010111000100011101100110001101111111001110111, 0b1100011010001000111010001000010101110000111010101010101010010011, 0b1111001010001111000111010010100100111111100111110010011100000001, 0b0100011011100000101110011010001001001111010111011010110101000101 };
			auto exp = test;
			constexpr uint8_t places = 0;

			rightShiftInPlace<4, places>(test);
			Assert::AreEqual(exp, test);
		}

		TEST_METHOD(RIGHT_SHIFT_1_PLACE) {
			Arr64<4> test = { 0b1001111010101010010110111100101110110010010110011000000101011101, 0b0010101001101100000010000101100000110011110000001010111111010000, 0b0000101011000001011000101011011010110010111001001111010000101110, 0b0111000001011001110110111110101010010000111101110010100010001010 };
			Arr64<4> exp = { 0b0100111101010101001011011110010111011001001011001100000010101110, 0b1001010100110110000001000010110000011001111000000101011111101000, 0b0000010101100000101100010101101101011001011100100111101000010111, 0b0011100000101100111011011111010101001000011110111001010001000101 };
			constexpr uint8_t places = 1;

			rightShiftInPlace<4, places>(test);
			Assert::AreEqual(exp, test);
		}

		TEST_METHOD(RIGHT_SHIFT_64_PLACES) {
			Arr64<4> test = { 0b0110101110101110000101110100100111100000001011011001000100111011, 0b1101111101000000100001001100100010011010011000011110000111001011, 0b1001000010101100111111111110001001111110010101011000101100100011, 0b1010110101000101000000111000001111110010101111011010011101100010 };
			Arr64<4> exp = { 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0110101110101110000101110100100111100000001011011001000100111011, 0b1101111101000000100001001100100010011010011000011110000111001011, 0b1001000010101100111111111110001001111110010101011000101100100011 };
			constexpr uint8_t places = 64;

			rightShiftInPlace<4, places>(test);
			Assert::AreEqual(exp, test);
		}

		TEST_METHOD(RIGHT_SHIFT_RAND_1) {
			Arr64<4> test = { 0b1111000110101101000010011001011011001111010110000010100100011011, 0b0111000100001011000011001000111110110001001000101110111001101110, 0b0011100001110100010010001010010001100001011110100001001100011110, 0b1101111001111001100110010100101010000110110111001100010100001100 };
			Arr64<4> exp = { 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000001111000110101101000010011001, 0b0110110011110101100000101001000110110111000100001011000011001000, 0b1111101100010010001011101110011011100011100001110100010010001010 };
			constexpr uint8_t places = 100;

			rightShiftInPlace<4, places>(test);
			Assert::AreEqual(exp, test);
		}

		TEST_METHOD(RIGHT_SHIFT_RAND_2) {
			Arr64<4> test = { 0b1101011110100101010010010000101110111100010101011011101100110101, 0b1001101111010110010001100000111100001111000010011010110010111101, 0b1011000001110001101010010000111101110110110110000100001100100111, 0b0111000111011110111000000111110111000001111111010100110100010010 };
			Arr64<4> exp = { 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000011010111101001010100100100001011101111, 0b0001010101101110110011010110011011110101100100011000001111000011 };
			constexpr uint8_t places = 154;

			rightShiftInPlace<4, places>(test);
			Assert::AreEqual(exp, test);
		}

		TEST_METHOD(RIGHT_SHIFT_RAND_3) {
			Arr64<4> test = { 0b0001010000000100010000110010101100111100111010110011010100110001, 0b1001010111001001010010011110010111101010110111110100100101011100, 0b1101101011011001101011000001100111011001111001000100101000010010, 0b1000111100001011100101110000110011000010111101101000110100110011 };
			Arr64<4> exp = { 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000 };
			constexpr uint8_t places = 254;

			rightShiftInPlace<4, places>(test);
			Assert::AreEqual(exp, test);
		}

		TEST_METHOD(RIGHT_SHIFT_RAND_4) {
			Arr64<4> test = { 0b0101110100100101111001100100010010111010011001100110100011010010, 0b0001111111101001000011000000001010001001001000101110100100110101, 0b1111110100011111001101110011111110100001010101011011011001110011, 0b0100011110000110011010010111000110100001101101110101100011101010 };
			Arr64<4> exp = { 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000010111010010010111100110010, 0b0010010111010011001100110100011010010000111111110100100001100000 };
			constexpr uint8_t places = 165;

			rightShiftInPlace<4, places>(test);
			Assert::AreEqual(exp, test);
		}

		TEST_METHOD(RIGHT_SHIFT_RAND_5) {
			Arr64<4> test = { 0b0101100101010011111010001100000111001011001110010010100101110001, 0b0110100111010111010101111001110100101110010110011011011011100101, 0b1110100000111101100001111111101100011010111110010100101100001110, 0b1010101100001000010101001011010000000001000011100001010111011000 };
			Arr64<4> exp = { 0b0000000000000000000000000000000000000000000000000000000000000000, 0b0000000000000000000000000000000000000000000010110010101001111101, 0b0001100000111001011001110010010100101110001011010011101011101010, 0b1111001110100101110010110011011011011100101111010000011110110000 };
			constexpr uint8_t places = 107;

			rightShiftInPlace<4, places>(test);
			Assert::AreEqual(exp, test);
		}

		TEST_METHOD(RIGHT_SHIFT_RAND_6) {
			Arr64<4> test = { 0b1011001101101111101011000111001011111101001110010100000010001001, 0b0001000110011000101100110001100000101010001100010010101110100001, 0b0011101101010111000111110011111001100111100011000110011111001100, 0b1010101111001000101011010101010010010101100001101001110111011000 };
			Arr64<4> exp = { 0b0000000000000000000000000000101100110110111110101100011100101111, 0b1101001110010100000010001001000100011001100010110011000110000010, 0b1010001100010010101110100001001110110101011100011111001111100110, 0b0111100011000110011111001100101010111100100010101101010101001001 };
			constexpr uint8_t places = 28;

			rightShiftInPlace<4, places>(test);
			Assert::AreEqual(exp, test);
		}
	};

	TEST_CLASS(ADD3) {
	public:
		TEST_METHOD(NO_ADDITIONS) {
			uint8_t test = 0b00110011;
			uint8_t exp = test;

			add3Module(test);
			Assert::AreEqual(exp, test);
		}

		TEST_METHOD(NO_ADDITIONS_BOUNDARY) {
			uint8_t test = 0b01000100;
			uint8_t exp = test;
			add3Module(test);

			Assert::AreEqual(exp, test);
		}

		TEST_METHOD(ONE_ADDITION_R) {
			uint8_t test = 0b00110111;
			uint8_t exp =  0b00111010;
			add3Module(test);
			Assert::AreEqual(exp, test);
		}

		TEST_METHOD(TWO_ADDITIONS) {
			uint8_t test = 0b01110111;
			uint8_t exp =  0b10101010;
			add3Module(test);
			Assert::AreEqual(exp, test);
		}

		TEST_METHOD(ONE_ADDITION_L) {
			uint8_t test = 0b01110011;
			uint8_t exp =  0b10100011;
			add3Module(test);
			Assert::AreEqual(exp, test);
		}
	};

	TEST_CLASS(GET_BIT) {
		const Arr64<4> testArr = { 0b1110101101000110010100001011110111001000000011100010111010001000, 0b0001101110011000001011010011010000111100101110010110000111000000, 0b1111000111111010101111001000011010101000110100100010011001011000, 0b0000010010000010100000011100110011001101011100001110100001100001 };
	public:
		TEST_METHOD(GET_BIT_0) {
			uint8_t expected = 1;
			uint8_t pos = 0;
			Assert::AreEqual(expected, getBit(testArr, pos));
		}

		TEST_METHOD(GET_BIT_1) {
			uint8_t expected = 1;
			uint8_t pos = 1;
			Assert::AreEqual(expected, getBit(testArr, pos));
		}
		TEST_METHOD(GET_BIT_64) {
			uint8_t expected = 0;
			uint8_t pos = 64;
			Assert::AreEqual(expected, getBit(testArr, pos));
		}
		TEST_METHOD(GET_RAND_0) {
			uint8_t expected = 1;
			uint8_t pos = 24;
			Assert::AreEqual(expected, getBit(testArr, pos));
		}
		TEST_METHOD(GET_RAND_1) {
			uint8_t expected = 0;
			uint8_t pos = 86;
			Assert::AreEqual(expected, getBit(testArr, pos));
		}
		TEST_METHOD(GET_RAND_2) {
			uint8_t expected = 0;
			uint8_t pos = 254;
			Assert::AreEqual(expected, getBit(testArr, pos));
		}
		TEST_METHOD(GET_RAND_3) {
			uint8_t expected = 1;
			uint8_t pos = 255;
			Assert::AreEqual(expected, getBit(testArr, pos));
		}
		TEST_METHOD(GET_RAND_4) {
			uint8_t expected = 1;
			uint8_t pos = 113;
			Assert::AreEqual(expected, getBit(testArr, pos));
		}
	};
}
